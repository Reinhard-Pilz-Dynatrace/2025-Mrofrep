[{"id":"1","name":"Environment setup","content":"<h2 id=\"environmentsetup\">Environment setup</h2>\n<h3 id=\"dtuhosteddevelopmentenvironment\">DTU hosted development environment</h3>\n<p>If this session is hosted by Dynatrace University, any preparation work has been done for you.\nWhat's left is to access your Dynatrace Environment and the DTU Dashboard.</p>\n<ul>\n<li>Click on <code>View Environment</code> to log into your Dynatrace Environment</li>\n<li>Clicking on <code>Open Terminal</code> will reveal the link to your DTU Dashboard</li>\n<li>Within the DTU Dashboard click on <code>Link</code> at the top of the screen</li>\n<li>Click on the link for <code>VSCode</code> to open up your development environment    </li>\n<li>Within the terminal at the bottom type in</li>\n</ul>\n<pre><code class=\"hljs\">docker compose up -d <span class=\"hljs-comment\">--build</span>\n</code></pre>\n<p>You can reuse that terminal for the rest of the session.</p>\n<p><img src=\"assets/01_setup_00_launch_ace_box.gif\" alt=\"ACEBox\" style=\"width:500px\" /></p>\n<h3 id=\"githubcodespaces\">GitHub CodeSpaces</h3>\n<p>In case you are using GitHub CodeSpaces (outside of this DTU Event), follow the rest of the instructions in this section.</p>\n<ol>\n<li>Create Dynatrace Access Token</li>\n<li>Configure and Start your GitHub Code Space</li>\n<li>Launch the Demo Application</li>\n</ol>","activityList":[{"id":"1.1","name":"Fork the GitHub Repository\r","content":"<h2 id=\"forkthegithubrepository\">Fork the GitHub Repository</h2>\n<p>The demo application of todays session is located on <a href=\"https://github.com/Reinhard-Pilz-Dynatrace/2025-Mrofrep\">GitHub</a>.</p>\n<p>You will need to fork that repository to your own GitHub Account in order to launch it.</p>\n<p><img src=\"assets/01_setup_01_fork_repository.png\" alt=\"Fork Repository\" style=\"width:500px\" /></p>\n<p><img src=\"assets/01_setup_02_create_fork.png\" alt=\"Fork Repository\" style=\"width:500px\" /></p>","activityList":[]},{"id":"1.2","name":"Configure Credentials\r","content":"<h2 id=\"configurecredentials\">Configure Credentials</h2>\n<p>You will be launching the demo app using GitHub Code Spaces.\nBefore we are able to do that, we need to configure two secrets in your GitHub account. They will let the app know where to report monitoring data to and how to authenticate.</p>\n<h3 id=\"createdynatraceapitoken\">üìå Create Dynatrace API Token</h3>\n<p>üìù <strong>Reference:</strong></p>\n<ul>\n<li><a href=\"https://docs.dynatrace.com/docs/manage/access-control/access-tokens#create-api-token\">How to create Access Token</a></li>\n<li><a href=\"https://docs.dynatrace.com/docs/shortlink/otel-getstarted-otlpexport#authentication-export-to-activegate\">Token scopes</a></li>\n</ul>\n<p>Select the following token scopes</p>\n<ul>\n<li>logs.ingest</li>\n<li>metrics.ingest</li>\n<li>openTelemetryTrace.ingest</li>\n<li>InstallerDownload</li>\n</ul>\n<p><center>\n<img src=\"assets/01_setup_03_create_token.gif\" alt=\"Create API Token\" style=\"width:500px\" />\n</center></p>\n<h3 id=\"createcodespacesecrets\">üìå Create Code Space Secrets</h3>\n<p>Within your GitHub Repository navigate to <code>Settings</code> and in there to <code>Secrets and variables</code> / <code>Codespaces</code>.\nIn here you need to define two secrets:</p>\n<ul>\n<li><code>DT_ENVIRONMENT_URL</code> needs to contain the URL of the Dynatrace environment for todays session (<code>https://######.live.dynatrace.com</code>)</li>\n<li><code>DT_API_TOKEN</code> needs to contain the API Token you have created earlier.\n<br>\n<br></li>\n</ul>\n<p><center>\n<img src=\"assets/01_setup_04_code_spaces_secrets.gif\" alt=\"Create API Token\" style=\"width:500px; display: block; align: center\" />\n</center></p>","activityList":[]},{"id":"1.3","name":"Launch Codespaces\r","content":"<h2 id=\"launchcodespaces\">Launch Codespaces</h2>\n<ul>\n<li>In your GitHub Repo click on the green <code>Code</code> button</li>\n<li>Select the <code>Codespaces</code> tab</li>\n<li>Click on <code>Create codespace on main</code></li>\n</ul>\n<p><center>\n<img src=\"assets/01_setup_05_create_code_space.gif\" alt=\"Create Code Space\" style=\"width:500px; display: block; align: center\" />\n</center></p>\n<p><br>\nGitHub needs about two minutes to provision your code space.</p>\n<p>Once you can see the folder structure on the left and a terminal is available, you are ready to move on.</p>","activityList":[]},{"id":"1.4","name":"How to start/stop the Demo Application\r","content":"<h2 id=\"howtostartstopthedemoapplication\">How to start/stop the Demo Application</h2>\n<p>Executing</p>\n<pre><code class=\"hljs\">docker compose up -d <span class=\"hljs-comment\">--build</span>\n</code></pre>\n<p>will launch several Docker containers.</p>\n<p><center>\n<img src=\"assets/01_setup_06_launch_demo_app.gif\" alt=\"Launch demo app\" style=\"width:500px; display: block; align: center\" />\n</center>\n<br /></p>\n<p>The first time you're executing that command several docker images are required to get pulled from Docker Hub. It will take about a minute until everything is up and running.</p>\n<p>Later on, during our Hands On tasks, you will have to make a couple of modifications to the source code and configuration of the demo app. You can relaunch the demo app with modifications by executing</p>\n<pre><code class=\"hljs\">docker compose up -d <span class=\"hljs-comment\">--build</span>\n</code></pre>\n<p>yet again. Docker will make sure your containers will get shut down and relaunched.</p>","activityList":[]}]},{"id":"2","name":"Extend out-of-the-box distributed tracing with OpenTelemetry\r","content":"<h2 id=\"extendoutoftheboxdistributedtracingwithopentelemetry\">Extend out-of-the-box distributed tracing with OpenTelemetry</h2>\n<p>Dynatrace's OneAgent is able to profile and instrument most programing languages. In most modern day application architectures, micro-services can come in a variety of programing languages. In order to enable distributed tracing across these polygot applications, Dynatrace leverages OpenTelemetry to extend its distributed tracing capabilites.</p>\n<p>For the hands-on exercises, we've assembled a demo application based on Java. While the Frontend API Server benefits from the deep monitoring capabilities of OneAgent, the injection of an Agent Module into the Backend Server is not possible.</p>\n<p>This section covers custom and automatic instrumentation with OpenTelemetry (traces) for Java, in order to link the spans produced within the Frontend all the way to the Backend, and form a complete distributed trace for each request.</p>\n<p>What you will learn</p>\n<ul>\n<li>How to create custom spans and link them to existing traces</li>\n<li>How to enrich spans with relevant details</li>\n<li>How to simplify efforts using auto-instrumentation</li>\n<li>How to propagate context between different processes</li>\n</ul>","activityList":[{"id":"2.1","name":"Basic plumbing for OpenTelemetry\r","content":"<h2 id=\"basicplumbingforopentelemetry\">Basic plumbing for OpenTelemetry</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>Before we can begin creating Spans and providing better insights into our <code>Order Backend</code>, we should first get an overview and understanding of the OpenTelemetry setup (<em>the plumbing</em>) that is already in place for these exercises.</p>\n<p>Reference Dynatrace documentation can be found at <a href=\"https://docs.dynatrace.com/docs/extend-dynatrace/opentelemetry/walkthroughs/java/java-manual\">this link</a>. While the concepts are still the same we adapted the setup for ease of use during this training.</p>\n<p>Let's find out what's involved.</p>\n<p>Open up the file <code>common/src/main/java/com/dtcookie/util/Otel.java</code>.</p>\n<h3 id=\"keyconcepts\">üìë Key Concepts</h3>\n<p>Expand each section as needed.\n<details>\n  <summary><strong>Create an OpenTelemetry Resource</strong></summary>\n  A resource is nothing more than the representation of an entity which produces telemetry data. In Dynatrace, Resources define the Services which tie together our observability signals (traces, metrics, logs). OpenTelemetry provides an implementation of <code>Resource</code> as part of its <code>SDK</code>, all we have to provide is attributes to describe this resouce.</p>\n<p>At the very minimum it pays off to define the attribute <code>service.name</code>. In our case we expect that value to be available as an Environment Variable. </p>\n<pre><code class=\"hljs java language-java\">Resource serviceName = Optional.ofNullable(System.getenv(<span class=\"hljs-string\">&quot;OTEL_SERVICE_NAME&quot;</span>))\n    .map(n -&gt; Attributes.of(AttributeKey.stringKey(<span class=\"hljs-string\">&quot;service.name&quot;</span>), n)).map(Resource::create)\n    .orElseGet(Resource::empty);\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note</strong>: <code>ResourceAttributes</code> allows us to access \"semantic attributes\" - industry set standards for attribute names</p>\n</blockquote>\n<p>Further down in <code>common/src/main/java/com/dtcookie/util/Otel.java</code> we attempt to interrogate the OneAgent for some Dynatrace-specific attributes.</p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-keyword\">for</span> (String name : <span class=\"hljs-keyword\">new</span> String[] { <span class=\"hljs-string\">&quot;dt_metadata_e617c525669e072eebe3d0f08212e8f2.properties&quot;</span>,\n        <span class=\"hljs-string\">&quot;/var/lib/dynatrace/enrichment/dt_metadata.properties&quot;</span> }) {\n    <span class=\"hljs-keyword\">try</span> {\n        Properties props = <span class=\"hljs-keyword\">new</span> Properties();\n        props.load(name.startsWith(<span class=\"hljs-string\">&quot;/var&quot;</span>) ? <span class=\"hljs-keyword\">new</span> FileInputStream(name) : <span class=\"hljs-keyword\">new</span> FileInputStream(Files.readAllLines(Paths.get(name)).get(<span class=\"hljs-number\">0</span>)));\n        dtMetadata = dtMetadata.merge(Resource.create(props.entrySet().stream().collect(Attributes::builder,\n                        (b, e) -&gt; b.put(e.getKey().toString(), e.getValue().toString()),\n                        (b1, b2) -&gt; b1.putAll(b2.build()))\n                .build()));\n    } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n    }\n}\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note</strong>: <code>dt_metadata_e617c525669e072eebe3d0f08212e8f2.json</code> is a file that contains a path under which OneAgent writes topology-specific dimensions related to the process reading it. This means we can provide Dynatrace with OneAgent supplied information about the Process that our Resource is running on. More on this in the <a href=\"https://www.dynatrace.com/support/help/shortlink/enrich-metrics#oneagent-file-open-interface\">online documentation</a>.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<p><details>\n<summary><strong>Set up Trace export</strong></summary></p>\n<p>With a resource in place that we can link our Traces to, all we need is a way to send our Traces to Dynatrace.</p>\n<p>Before we can make use of the endpoint, we must define our \"ingest pipeline\". This consists of:</p>\n<ul>\n<li><strong>Trace Provider</strong> - mandatory to start tracing and it associates traces with a Resource</li>\n<li><strong>Span Processor</strong> - watches the lifecycle of spans and sends them to an exporter when appropriate; we are using a <code>Batch Span Processor</code> which batches spans together and compresses data before sending it</li>\n<li><strong>Span Exporter</strong> - converts the spans to the required format for the backend platform; we are using the <code>OTLP Span Exporter</code> to send spans in OTLP format to the Dynatrace API</li>\n</ul>\n<p>OpenTelemetry offers various ways to define that pipeline. For our workshop we have chosen to use Environment Variables - just to keep things simple.</p>\n<p>Open up the file <code>order-backend/Dockerfile</code>. You can see this all in action with the following environment properties. </p>\n<pre><code class=\"hljs properties language-properties\"><span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_JAVA_GLOBAL_AUTOCONFIGURE_ENABLED=true</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_SERVICE_NAME=order-backend-${GITHUB_USER}</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_PROPAGATORS=tracecontext</span>\n\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_TRACES_EXPORTER=otlp</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_EXPORTER_OTLP_TRACES_PROTOCOL=http/protobuf</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=http://opentelemetry-collector:4318/v1/traces</span>\n</code></pre>\n<p>That's it! With these settings in place you can access the Global OpenTelemetry instance from anywhere within your source code and create a Tracer.<br/>\nOur order-backend does that on lines <code>40-41</code> of the source file <code>order-backend/src/main/com/dtcookie/shop/backend/BackendServer.java</code>. From this point on anywhere within this Java class a tracer will be available for use.</p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> OpenTelemetry openTelemetry = GlobalOpenTelemetry.get();\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Tracer tracer = openTelemetry.getTracer(<span class=\"hljs-string\">&quot;manual-instrumentation&quot;</span>);\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"yourtaskexplorethedistributedtracesenrichedbyopentelemetry\">üìå Your Task: Explore the distributed traces enriched by OpenTelemetry</h3>\n<ol>\n<li>Open up <code>order-backend/Dockerfile</code></li>\n<li>Remove the comment (<code>#</code>) from lines <code>27-35</code>. (<strong><em>shortcut:</em></strong> highlight lines 27-35 and use the keyboard CTRL+/ for windows, CMD+/ for mac)</li>\n<li>Restart the Demo application (<code>docker compose up -d --build</code>)</li>\n<li>Familiarize yourself with the code in the file <code>common/src/main/java/com/dtcookie/util/Otel.java</code>.</li>\n<li>Explore the improvements regarding visibility within the collected traces for <code>/place-order</code><ul>\n<li>Go to Services</li>\n<li>Click on <code>order-api-[github-user-name]</code></li>\n<li>Inspect a more recent <code>/place-order</code> trace to become available within <code>Distributed traces</code></li>\n<li>Inspect the <code>Resource Attributes</code> of one of the additional spans (example <code>process</code> span)</li></ul></li>\n</ol>\n<h4 id=\"questions\">Questions</h4>\n<p><details><summary>üí° Where is the attribute <mark>service.name</mark> coming from?</summary>The <mark>serviceName</mark> attributes defined in Otel.java</details></p>\n<h3 id=\"verifyresults\">‚úÖ Verify Results</h3>\n<p>You have completed this exercise once you can visualize in Dynatrace that the credit card validation is getting picked up by the Order Backend.</p>","activityList":[]},{"id":"2.2","name":"Java Auto Instrumentation\r","content":"<h2 id=\"javaautoinstrumentation\">Java Auto Instrumentation</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>The Order Backend is now able to report traces into Dynatrace. But the only additional visibility we <strong>are</strong> getting is, that the an inbound call to validate credit cards is getting successfully picked up. We could have figured that out by just looking at the outbound HTTP call on the Frontend - and Dynatrace was capturing that already out of the box.</p>\n<p>The developer of the Order Backend simply didn't spend a lot of thoughts on observability - and the same thing can be said about the libraries the backend depends on.</p>\n<p>Luckily this is not the end of the road. For well known frameworks and libraries the OpenTelemetry community has already come up with a solution, that's based on auto-instrumentation.</p>\n<p>In this exercise you'll add OpenTelemetry's auto-instrumentation for Java in order to get even more insight into what's happening within the Order Backend.</p>\n<h3 id=\"keyconcepts\">üìë Key Concepts</h3>\n<p><details>\n  <summary><strong>What is auto-instrumentation</strong></summary></p>\n<p>Auto-instrumentation is a way of adding core observability signals to a previously unmonitored system. Using common knowledge about the techonology, many frameworks come with packages/modules which are ready to automate the core interactions within.</p>\n<p>While saving a lot of effort, auto-instrumentation won't know about the deeper innerworkings of the system. Chances are, you'll still have to customize or create additional spans to fully observe your system.</p>\n<p></details></p>\n<p><br/></p>\n<p><details>\n  <summary><strong>Auto-instrumentation for Java</strong></summary></p>\n<p>Because the Order Backend is based on Java, the obvious solution for auto-instrumentation is to attach a Java Agent to the JVM.<br />\n  Normally OneAgent would be able to perform exactly that job, but in this special case it's not able to inject the Agent Module for Deep Monitoring. </p>\n<p>The Dockerfile of the Order backend (<code>order-backend/Dockerfile</code>) already downloads the OpenTelemetry Java Agent. Attaching that Agent to the Backend JVM can get achieved via JVM Argument <code>-javaagent:opentelemetry-javaagent.jar</code>.</p>\n<p>The effect will be that a long list of <a href=\"https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks\">supported libraries</a> will automatically get enriched with the capability to report traces and spans via OpenTelemetry.<br />\n</details></p>\n<p><br/></p>\n<h3 id=\"yourtasks\">üìå Your Tasks</h3>\n<p>In <code>order-backend/Dockerfile</code> navigate to line <code>63</code>. It tells Docker which process should keep the container alive.</p>\n<p><code>ENTRYPOINT [\"java\", \"-jar\", \"order-backend.jar\"]</code></p>\n<p>All we need to do here is to add a JVM argument.</p>\n<p><code>ENTRYPOINT [\"java\", \"-javaagent:opentelemetry-javaagent.jar\", \"-jar\", \"order-backend.jar\"]</code></p>\n<p>The next time you are launching the demo application it will ensure that the OpenTelemetry Agent is getting attached to the backend.</p>\n<p>Restart the Demo Application (<code>docker compose up -d --build</code>)</p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Open the <code>order-api</code> service in Dynatrace and open one of the <code>/place-order</code> traces from its Distributed traces. </p>\n<p>Verify new visibility within the traces:</p>\n<ul>\n<li><code>process</code> is reaching out to the Database</li>\n<li>Within <code>process</code> additional <code>post-process</code> spans are visible</li>\n<li><code>post-process</code> is also reaching out to the Database</li>\n<li>The backend responds back via asynchronous <code>GET</code> request to the frontend <code>order-api</code></li>\n<li>Inspect the span metadata of these additional spans, specifically the <code>Instrumentation scope</code> and the <code>thread.name</code></li>\n</ul>\n<h3 id=\"questions\">üí° Questions</h3>\n<ul>\n<li>Which of these spans got introduced by auto-instrumentation?</li>\n<li>Take a detailed look at method <code>process</code> at line <code>70</code> in <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer</code>. On line <code>76</code> it is scheduling the invocation of <code>postprocess</code> to be executed by a Thread Pool. What could have been the reason for <code>postprocess</code> not reporting any spans until we've enabled Auto Instrumentation?</li>\n</ul>","activityList":[]},{"id":"2.3","name":"Correlate 2 services in a single trace\r","content":"<h2 id=\"correlate2servicesinasingletrace\">Correlate 2 services in a single trace</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>Now that we're familiar with the OpenTelemetry setup, it's time to start tracing a few missing transactions.</p>\n<p>You may have noticed in the previous exercise, that the <code>/place-order</code> traces of service <code>order-api</code> are not only reaching out to the backend for credit card validation.<br />\nAnother backend call addresses <code>order-backend:54041/check-inventory/....</code>. And after checking out the distributed traces of <code>order-backend</code> it becomes clear, that the order backend is <strong>already</strong> reporting the incoming web requests to Dynatrace.</p>\n<p>One of the topics in this exercise we will be to make sure that Dynatrace is able to correlate both sides and show them within a single trace.</p>\n<p>Head over to <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer.java</code> to begin.</p>\n<h3 id=\"keyconcepts\">üìë Key Concepts</h3>\n<p>Expand each section as needed.</p>\n<p><details>\n  <summary><strong>Create custom Spans</strong></summary></p>\n<p>In Java, Spans can be created by first aquiring a <code>tracer</code>. Tracers offer the functionality to build and start Spans.</p>\n<p><strong>Example</strong></p>\n<pre><code class=\"hljs java language-java\">Tracer tracer = GlobalOpenTelemetry.get().getTracer(<span class=\"hljs-string\">&quot;my-tracer-name&quot;</span>);\nSpan span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;my-span&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n<span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// perform some business logic in here</span>\n  <span class=\"hljs-comment\">// ...</span>\n} <span class=\"hljs-keyword\">finally</span> {\n  span.end();\n}\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note:</strong> It is usually not necessary to create a Tracer every time you want to create a Span. In our demo app the BackendServer creates a reusable <code>tracer</code> right in the beginning - on line <code>41</code>.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<p><details>\n  <summary><strong>Set Span Context</strong></summary></p>\n<p>We can think of <code>Context</code> as the glue that holds all Spans together in the same Trace. When a transaction goes across different processes and resources, the default OpenTelemetry behavior is to assign a new <code>Context</code> to each Span, thus creating separate transactions. We can modify this behavior by propagating <code>Context</code> across traces.</p>\n<p><strong>For incoming traces‚Ä¶</strong></p>\n<p>The method <code>handleCreditcards</code> within our BackendServer is already taking care of <code>Context Propagation</code> properly.<br />\n  Before it attempts to create a Span, it inspects the HTTP Request Headers - specifically it looks for the Headers <code>traceparent</code> and <code>traceid</code>. A <code>Context</code> based on these headers tells Dynatrace, which Client Side HTTP Request this Server Side matches up with.</p>\n<pre><code class=\"hljs java language-java\">Context ctx = openTelemetry.getPropagators().getTextMapPropagator().extract(Context.current(), request, getter);\n<span class=\"hljs-keyword\">try</span> (Scope ctScope = ctx.makeCurrent()) {\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note:</strong> We've hidden a few details here to keep things simple. If you're interested in how a <code>Context Propagator</code> needs to get implemented, take a look at method <code>newRequestHeaderGetter()</code> in <code>Otel.java</code>.</p>\n</blockquote>\n<p><strong>For outgoing Traces‚Ä¶</strong></p>\n<p>On the client side things are working very similar. Instead of <strong>extracting</strong> the <code>Context</code> it needs to get <strong>injected</strong> into outgoing call. Like in this example, where the necessary headers are getting added to an outgoing HTTP Request.</p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-comment\">// Tell OpenTelemetry to inject the context in the HTTP headers</span>\nTextMapSetter&lt;HttpURLConnection&gt; setter =\n  <span class=\"hljs-keyword\">new</span> TextMapSetter&lt;HttpURLConnection&gt;() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">set</span><span class=\"hljs-params\">(HttpURLConnection carrier, String key, String value)</span> </span>{\n        <span class=\"hljs-comment\">// Insert the context as Header</span>\n        carrier.setRequestProperty(key, value);\n    }\n};\n\nURL url = <span class=\"hljs-keyword\">new</span> URL(<span class=\"hljs-string\">&quot;...&quot;</span>);\nSpan outGoing = tracer.spanBuilder(<span class=\"hljs-string\">&quot;/GET &quot;</span> + url).setSpanKind(SpanKind.CLIENT).startSpan();\n<span class=\"hljs-keyword\">try</span> (Scope scope = outGoing.makeCurrent()) {\n  <span class=\"hljs-comment\">// Use the Semantic Conventions.</span>\n  <span class=\"hljs-comment\">// (Note that to set these, Span does not *need* to be the current instance in Context or Scope.)</span>\n  outGoing.setAttribute(SemanticAttributes.HTTP_METHOD, <span class=\"hljs-string\">&quot;GET&quot;</span>);\n  outGoing.setAttribute(SemanticAttributes.HTTP_URL, url.toString());\n  HttpURLConnection transportLayer = (HttpURLConnection) url.openConnection();\n\n  <span class=\"hljs-comment\">// Inject the request with the *current*  Context, which contains our current Span.</span>\n  openTelemetry.getPropagators().getTextMapPropagator().inject(Context.current(), transportLayer, setter);\n\n  <span class=\"hljs-comment\">// Make outgoing call</span>\n} <span class=\"hljs-keyword\">finally</span> {\n  outGoing.end();\n}\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note:</strong> The <code>HttpURLConnection</code> above will now hold the trace context that is needed to stitch any downstream spans to this current one.</p>\n</blockquote>\n<p></details></p>\n<p><br/></p>\n<p><details>\n  <summary><strong>Setting Span Kind</strong></summary></p>\n<p>You may have noticed in the previous examples the term <code>Span Kind</code>. Not all Spans are getting treated equally. There are several possible kinds:</p>\n<ul>\n<li><p><strong>SERVER</strong> - span covers server-side handling of a synchronous request</p></li>\n<li><p><strong>CLIENT</strong> - span describes a request to some remote service</p></li>\n<li><p><strong>PRODUCER</strong> - span describes the inititor of an asynchronous request</p></li>\n<li><p><strong>CONSUMER</strong> - span describes a child of an asynchronous request</p></li>\n<li><p><strong>INTERNAL</strong> - (default value) representing an internal operation without remote calls</p>\n<p>In other words, setting the Span Kind like in this example</p></li>\n</ul>\n<pre><code class=\"hljs java language-java\">  Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;my-span&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n</code></pre>\n<p>is optional. If you want to signal that a synchronous request has been received, the OpenTelemetry SDK expects you to signal that</p>\n<pre><code class=\"hljs java language-java\">  Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;my-span&quot;</span>).setSpanKind(SpanKind.SERVER).startSpan();\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"yourtask\">üìå Your Task</h3>\n<p>In <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer.java</code>:</p>\n<ol>\n<li>Search for the method <code>handleCreditcards</code>. We have seen in our previous tasks, that Dynatrace receives correct signals at this point.</li>\n<li>Search for the method <code>handleInventory</code>. The nature of this method is <strong>very</strong> similar to <code>handleCreditCards</code> - it receives a HTTP request.<ul>\n<li>Compare both methods regarding the OpenTelemetry SDK calls</li>\n<li>Method <code>handleInventory</code> does not yet handle <code>Context Propagation</code> correctly</li>\n<li>Use <code>handleCreditCards</code> as a template to fix <code>handleInventory</code>    </li></ul></li>\n<li>Restart the demo application to verify any changes:</li>\n</ol>\n<p><details>\n  <summary>Show solution</summary></p>\n<pre><code class=\"hljs java language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">handleInventory</span><span class=\"hljs-params\">(HttpServletRequest request)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        String url = request.getRequestURI();\n        String productName = url.substring(url.lastIndexOf(<span class=\"hljs-string\">&quot;/&quot;</span>));\n        <span class=\"hljs-keyword\">int</span> quantity = <span class=\"hljs-number\">1</span>;\n\n        Context ctx = openTelemetry.getPropagators().getTextMapPropagator().extract(Context.current(), request, getter);\n\n        <span class=\"hljs-keyword\">try</span> (Scope ignored = ctx.makeCurrent()) {\n            Span serverSpan = tracer.spanBuilder(request.getRequestURI()).setSpanKind(SpanKind.SERVER).startSpan();\n            <span class=\"hljs-keyword\">try</span> (Scope scope = serverSpan.makeCurrent()) {\n                serverSpan.setAttribute(SemanticAttributes.HTTP_REQUEST_METHOD, request.getMethod().toUpperCase());\n                serverSpan.setAttribute(SemanticAttributes.URL_SCHEME, <span class=\"hljs-string\">&quot;http&quot;</span>);\n                serverSpan.setAttribute(SemanticAttributes.SERVER_ADDRESS, <span class=\"hljs-string\">&quot;order-backend-&quot;</span> + System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>) + <span class=\"hljs-string\">&quot;:&quot;</span> + Ports.INVENTORY_LISTEN_PORT);\n                serverSpan.setAttribute(SemanticAttributes.URL_PATH, request.getRequestURI());\n\n                Database.execute(<span class=\"hljs-string\">&quot;SELECT * FROM products WHERE name = &#x27;&quot;</span> + productName + <span class=\"hljs-string\">&quot;&#x27;&quot;</span>);\n\n                checkStorageLocations(productName, quantity);\n\n                serverSpan.setAttribute(SemanticAttributes.HTTP_RESPONSE_STATUS_CODE, <span class=\"hljs-number\">200</span>);\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;done&quot;</span>;\n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n                serverSpan.setAttribute(SemanticAttributes.HTTP_RESPONSE_STATUS_CODE, <span class=\"hljs-number\">500</span>);\n                serverSpan.recordException(e);\n                serverSpan.setStatus(StatusCode.ERROR);\n                log.warn(<span class=\"hljs-string\">&quot;checking inventory failed&quot;</span>, e);\n                <span class=\"hljs-keyword\">throw</span> e;\n            } <span class=\"hljs-keyword\">finally</span> {\n                serverSpan.end();\n            }\n        }\n    }\n</code></pre>\n<p></details>\n<br/></p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Open the <code>order-api</code> service in Dynatrace and open one of the <code>/place-order</code> traces from its Distributed traces. </p>\n<p>The HTTP GET Request <code>/check-inventory</code> should now extend into the Order Backend.</p>","activityList":[]},{"id":"2.4","name":"House Cleaning\r","content":"<h2 id=\"housecleaning\">House Cleaning</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>We've now learned how OpenTelemetry Signals are getting produced - either because the application already was pre-instrumented or when auto-instrumentation kicked in and added even more visibility.</p>\n<p>But unless you're in charge of adding the code snippets that are talking to the OpenTelemetry SDK you don't seem to have control over how much of that data eventually ends up at your OpenTelemetry Backend.</p>\n<p>‚Ä¶. unless your OpenTelemetry Backend is Dynatrace.</p>\n<h3 id=\"yourtasks\">üìå Your Tasks</h3>\n<p>The developer who was in charge of adding OpenTelemetry Spans to the Frontend Server was a bit overzealous. If you take a detailed look at the <code>/place-order</code> traces, you'll notice that they contain spans named <code>persist-purchase-confirmation-#</code> - in an unnecessarily high amount.</p>\n<p>In your Dynatrace Environment navigate to <code>Settings Classic &gt; Server-side service monitoring</code>.\nFind a way to exclude all the spans that start with the name <code>persist-purchase-confirmation-</code> from getting captured by Dynatrace.</p>\n<blockquote>\n  <p>üí° <strong>Note:</strong> This feature requires OneAgent Fullstack to be present. It doesn't apply to traces ingested via OTLP.</p>\n</blockquote>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Open the <code>order-api</code> service in Dynatrace and open one of the <code>/place-order</code> traces from its Distributed traces. </p>\n<p>The spans that have been previously spammed your traces should now be gone</p>\n<h3 id=\"questions\">üí° Questions</h3>\n<ul>\n<li>Why was it not required to restart your Demo Application in that case?</li>\n</ul>","activityList":[]},{"id":"2.5","name":"Creating Spans within the Order Backend\r","content":"<h2 id=\"creatingspanswithintheorderbackend\">Creating Spans within the Order Backend</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>Head over to <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer.java</code> to begin.</p>\n<p>Spans can be manually created to allow for custom/fine grain naming. This action is commonly known as <strong><em>instrumentation</em></strong> and the objective is to collect \"telemetry data\".</p>\n<h3 id=\"keyconcepts\">üìë Key Concepts</h3>\n<p>Expand as needed.</p>\n<p><details>\n  <summary><strong>Create custom Spans</strong></summary></p>\n<p>In Java, Spans can be created by first aquiring a <code>tracer</code>. Tracers offer the functionality to build and start Spans.</p>\n<p><strong>Example</strong></p>\n<pre><code class=\"hljs java language-java\">Tracer tracer = GlobalOpenTelemetry.get().getTracer(<span class=\"hljs-string\">&quot;my-tracer-name&quot;</span>);\nSpan span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;my-span&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n<span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-comment\">// perform some business logic in here</span>\n  <span class=\"hljs-comment\">// ...</span>\n} <span class=\"hljs-keyword\">finally</span> {\n  span.end();\n}\n</code></pre>\n<blockquote>\n  <p>üìù <strong>Note:</strong> It is usually not necessary to create a Tracer every time you want to create a Span. In our demo app the BackendServer creates a reusable <code>tracer</code> right in the beginning - on line <code>41</code>.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<h3 id=\"yourtask\">üìå Your Task</h3>\n<p>In <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer.java</code>:</p>\n<ol>\n<li>Search for the method <code>checkStorageLocations</code>. In here the Storage Locations are getting checked whether the requested quantity of a specific product is available. It eventually calls the method <code>deductFromLocation</code> which can be found a little farther below. </li>\n<li>Create an additional Span whenever <code>deductFromLocation</code> is getting invoked. You can use <code>checkStorageLocations</code> in order to figure out what additional code is necessary.   </li>\n<li>Restart the demo application to verify any changes:</li>\n</ol>\n<p><details>\n  <summary>Show solution</summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deductFromLocation</span><span class=\"hljs-params\">(StorageLocation location, String productName, <span class=\"hljs-keyword\">int</span> quantity)</span> </span>{\n    Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;deduct&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n    <span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n      location.deduct(productName, quantity);\n    } <span class=\"hljs-keyword\">finally</span> {\n      span.end();\n    }\n}\n</code></pre>\n<p></details>\n<br/></p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Open the <code>order-api</code> service in Dynatrace and open one of the <code>/place-order</code> traces from its Distributed traces. </p>\n<p>Except for a few outliers these Traces should now contain the new Span - signalling that a suitable storage location has been found from which to deduct the ordered product(s). We will deal with these outliers in our next excercise.</p>","activityList":[]},{"id":"2.6","name":"Customizing Spans for better insights\r","content":"<h2 id=\"customizingspansforbetterinsights\">Customizing Spans for better insights</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>While tracing provides us the most basic visibility into our transactions and allows to see the end-to-end picture, in most cases there will be a need to capture additional detail relevant to troubleshooting problems.</p>\n<p>In this exercise you'll modify your previously created Spans to capture additional details.</p>\n<h3 id=\"keyconcepts\">üìë Key Concepts</h3>\n<p><details>\n  <summary><strong>Adding attributes</strong></summary></p>\n<p>Spans allow us to store simple custom information relevant to our troubleshooting as Attributes. If you're familiar with Dynatrace Request Attributes, OpenTelemetry's Span attributes are very similar.</p>\n<p>To add an attribute we can use the <code>setAttribute</code> function of the Span which takes the name and value of the attribute:</p>\n<pre><code class=\"hljs java language-java\">Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;&lt;span-name&gt;&quot;</span>).startSpan();\n<span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n    span.setAttribute(<span class=\"hljs-string\">&quot;&lt;attribute-name&gt;&quot;</span>, attributeValue);\n    <span class=\"hljs-comment\">// business logic</span>\n} <span class=\"hljs-keyword\">finally</span> {\n    span.end();\n}\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<p><details>\n  <summary><strong>Recording events</strong></summary></p>\n<p>While attributes are great for storing simple single values, events can carry more information and mark a specific meaningful point in time.</p>\n<p>Adding an event is done using <code>addEvent</code>, which takes the title of the event and optionally a set of attributes of the event. Here's an example:</p>\n<pre><code class=\"hljs java language-java\">Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;&lt;span-name&gt;&quot;</span>).startSpan();\n<span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n    <span class=\"hljs-comment\">// business logic</span>\n\n    <span class=\"hljs-comment\">// add a simple event without attributes</span>\n    span.addEvent(<span class=\"hljs-string\">&quot;&lt;attribute-title&gt;&quot;</span>);\n    <span class=\"hljs-comment\">// add an event with attributes</span>\n    span.addEvent(<span class=\"hljs-string\">&quot;&lt;attribute-title&gt;&quot;</span>, Attributes.builder().put(<span class=\"hljs-string\">&quot;&lt;attribute-name&gt;&quot;</span>, productName).build());\n\n    <span class=\"hljs-comment\">// business logic</span>\n} <span class=\"hljs-keyword\">finally</span> {\n    span.end();\n}  \n</code></pre>\n<p></details></p>\n<p><br/></p>\n<p><details>\n  <summary><strong>Recording failures</strong></summary></p>\n<p>Very often our code will be designed to handle failures and either recover or take an alternative path. However, for monitoring purposes, we want to be aware of any internal graceful failures that don't necessarily stop a transaction.</p>\n<p>For this purpose, OpenTelemetry allows setting a status for a Span which can be <code>Unset</code>, <code>Ok</code>, or <code>Error</code>. Similar to recording events, failure details including stack traces can be recorded using the <code>recordException</code> method which takes an <code>Exception</code>/<code>Throwable</code> along with optional attributes.</p>\n<p>You can see this in action in <code>BackendServer.java</code> on lines <code>150-152</code>:</p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-keyword\">try</span> {\n  ...\n} <span class=\"hljs-keyword\">catch</span> (Exception e) {\n    serverSpan.setAttribute(SemanticAttributes.HTTP_RESPONSE_STATUS_CODE, <span class=\"hljs-number\">500</span>);\n    serverSpan.recordException(e);\n    serverSpan.setStatus(StatusCode.ERROR);\n}\n</code></pre>\n<p></details>\n<br/></p>\n<h3 id=\"yourtasks\">üìå Your Tasks</h3>\n<p>In <mark>BackendServer.java</mark> revisit the methods <code>deductFromLocation</code> and <code>checkStorageLocations</code>:</p>\n<ol>\n<li>Add the attributes <code>product.name</code>, <code>location.name</code> and <code>quantity</code> to the Span you have introduced to <code>deductFromLocation</code> in the earlier exercise.</li>\n<li>In case <code>checkStorageLocations</code> doesn't find a suitable location with enough products available, add an event named <code>nothing deducted</code> to the Span <code>check-storage-locations</code>. Optionally, also add an attribute <code>product.name</code> to the event.</li>\n<li>In addition to that Event, let's also set the Span Status, signalling that this is some sort of error.  </li>\n</ol>\n<blockquote>\n  <p>üí° <strong>Hint:</strong> You can get the name of a StorageLocation by calling <code>location.getName()</code></p>\n</blockquote>\n<ol start=\"4\">\n<li>Restart the application to verify any changes:</li>\n</ol>\n<p><details>\n  <summary>Show solution</summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkStorageLocations</span><span class=\"hljs-params\">(String productName, <span class=\"hljs-keyword\">int</span> quantity)</span> </span>{\n    Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;check-storage-locations&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n    <span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n        <span class=\"hljs-keyword\">boolean</span> deducted = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">for</span> (StorageLocation location : StorageLocation.getAll()) {\n            <span class=\"hljs-keyword\">if</span> (location.available(productName, quantity)) {\n                deductFromLocation(location, productName, quantity);\n                deducted = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (!deducted) {\n            span.addEvent(<span class=\"hljs-string\">&quot;nothing deducted&quot;</span>, io.opentelemetry.api.common.Attributes.builder().put(<span class=\"hljs-string\">&quot;product.name&quot;</span>, productName).build());\n            span.setStatus(StatusCode.ERROR);\n        }\n    } <span class=\"hljs-keyword\">finally</span> {\n        span.end();\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">deductFromLocation</span><span class=\"hljs-params\">(StorageLocation location, String productName, <span class=\"hljs-keyword\">int</span> quantity)</span> </span>{\n    Span span = tracer.spanBuilder(<span class=\"hljs-string\">&quot;deduct&quot;</span>).setSpanKind(SpanKind.INTERNAL).startSpan();\n    <span class=\"hljs-keyword\">try</span> (Scope scope = span.makeCurrent()) {\n        span.setAttribute(<span class=\"hljs-string\">&quot;product.name&quot;</span>, productName);\n        span.setAttribute(<span class=\"hljs-string\">&quot;location.name&quot;</span>, location.getName());\n        span.setAttribute(<span class=\"hljs-string\">&quot;quantity&quot;</span>, quantity);\n        location.deduct(productName, quantity);\n      } <span class=\"hljs-keyword\">finally</span> {\n        span.end();\n      }\n    }\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Open the <code>order-api</code> service in Dynatrace and open one of the <code>/place-order</code> traces from its Distributed traces. </p>\n<p>You should verify that your attributes have been registered.<br />\nAny orders where no location to deduct the product(s) from could be found, should also have an Event attached and should be flagged as erroneous. You can view your event in the Events tab, and depending on the span you may also observe a failure recorded in the Errors tab.</p>\n<blockquote>\n  <p>üìë <strong>Note:</strong> Span and event attributes are not captured by Dynatrace by default. When you first see your attribute, click the <code>+</code> button to store it on future traces.</p>\n</blockquote>","activityList":[]}]},{"id":"3","name":"Metrics, dashboards, alerts in context\r","content":"<h2 id=\"metricsdashboardsalertsincontext\">Metrics, dashboards, alerts in context</h2>\n<p>This section covers how to create and populate measurements via OpenTelemetry for Java.</p>\n<p>What you will learn</p>\n<ul>\n<li>How to create and populate custom metrics using OpenTelemetry</li>\n<li>How to visualize these metrics in Dynatrace</li>\n<li>How to alert on these metrics</li>\n</ul>\n<p><br /></p>\n<hr/>\n<blockquote>\n  <p>üí° <strong>Hint:</strong> If you got lost in the previous section executing the command below will take care of everything</p>\n</blockquote>\n<pre><code class=\"hljs\">docker compose down <span class=\"hljs-variable\">&amp;&amp;</span> git <span class=\"hljs-meta\">reset</span> --hard <span class=\"hljs-variable\">&amp;&amp;</span> git checkout tracing-finished\n</code></pre>","activityList":[{"id":"3.1","name":"Enhance the existing OpenTelemetry metric definitions\r","content":"<h2 id=\"enhancetheexistingopentelemetrymetricdefinitions\">Enhance the existing OpenTelemetry metric definitions</h2>\n<p>In this section, we will enhance the existing OpenTelemetry metric definitions by adding an additional attribute.</p>\n<h3 id=\"task1enhancetheexistingmetrics\">üìå Task #1: Enhance the existing metrics</h3>\n<p><strong>Your Task:</strong> Enhance the existing metrics by adding an additional attribute</p>\n<p>In the file <code>order-api/src/main/java/com/dtcookie/shop/frontend/FrontendServer.java</code>, the functions <code>reportPurchases</code> and <code>reportExpectedRevenue</code> have been updated to include an attribute with the key <code>user</code> and the value <code>System.getenv(\"GITHUB_USER\")</code>, allowing metrics to be tied to individual attendee instances. Please update the <code>reportActualRevenue</code> function to include the same attribute.</p>\n<p><details>\n  <summary>Solution: Expand to copy and paste the code</summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">reportActualRevenue</span><span class=\"hljs-params\">(Product product)</span> </span>{\n    Attributes attributes = Attributes.builder()\n    .put(AttributeKey.stringKey(<span class=\"hljs-string\">&quot;product&quot;</span>), product.getName())\n    .put(AttributeKey.stringKey(<span class=\"hljs-string\">&quot;user&quot;</span>), System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>))\n    .build();\n\n    actualRevenueCounter.add(product.getPrice(), attributes);       \n}\n</code></pre>\n<p></details>\n<br/>\nAfter making the changes above, restart your application by running <code>docker compose up -d --build</code> in the terminal.</p>\n<h4 id=\"task2uploadshopapplicationoverviewdashboard\">üìå Task #2: Upload <code>Shop Application Overview</code> dashboard</h4>\n<p>Download the following JSON to your local machine.\n<a href=\"https://dt-url.net/nb2y0zo2\">Shop Application Overview.json</a></p>\n<p>Then upload the dashboard to your tenant - navigate to <code>Apps</code>, open the <code>Dashboards</code> app, and select <code>Upload</code>.</p>\n<p><img src=\"assets/03-01-02-upload.png\" alt=\"Upload Dashboard\" /></p>\n<h3 id=\"task3chartametric\">üìå Task #3: Chart a metric</h3>\n<p><strong>Your Task:</strong> Configure a total revenue tile</p>\n<ol>\n<li>Click on the first empty tile (top left) under <code>Business Analytics</code>, then the pencil icon to edit the tile.</li>\n</ol>\n<p><img src=\"assets/03-01-03-pencil.png\" alt=\"Edit Tile\" /></p>\n<ol start=\"2\">\n<li>Navigate to the <code>Select metric</code> dropdown, search for <code>shop.revenue.actual</code> and select the metric.</li>\n<li>Change the <code>avg</code> aggregation dropdown to <code>sum</code>.</li>\n<li>Click on <code>Type to filter</code> and set the filter <code>user = &lt;your-github-username&gt;</code>.\nHint: To complete the step, click outside of the filter dropdown.</li>\n<li>Click on <code>Run</code> and verify the metric is being captured by Dynatrace by viewing the chart.</li>\n<li>In order to use a single value tile, click on the <code>+</code> under the <code>Split by</code> and select <code>Reduce to single value</code>.</li>\n</ol>\n<p><img src=\"assets/03-01-03-single_value.png\" alt=\"Single value\" /></p>\n<ol start=\"7\">\n<li>Under the <code>Reduce to single value</code> dropdown, select <code>Sum</code>. </li>\n<li>Click on <code>Run</code> again.</li>\n<li>Navigate to the <code>Visual</code> tab, and select <code>Single value</code> for visualization.</li>\n<li>Expand the <code>Data mapping</code> configuration category:<ul>\n<li>Set <code>Single value</code> to <code>sum(shop.revenue.actual)</code></li></ul></li>\n<li>Expand the <code>Single value</code> configuration category:<ul>\n<li>Set <code>Label</code> to <code>Total Revenue</code></li></ul></li>\n<li>Close out of the edit window of the tile.</li>\n</ol>\n<p><details>\n  <summary>Results:</summary>\n  <img src=\"assets/03-01-03-complete.png\" alt=\"Tile 1\" />\n</details></p>\n<p><br/></p>\n<h3 id=\"optionalchallengertask\">üìå (Optional) Challenger Task</h3>\n<p><strong>Your Task:</strong> Modify all of the populated tiles under <code>Business Analytics</code> by adding a filter on the new <code>user</code> attribute/dimension.</p>\n<hr />","activityList":[]},{"id":"3.2","name":"Create new OpenTelemetry metric definition\r","content":"<h2 id=\"createnewopentelemetrymetricdefinition\">Create new OpenTelemetry metric definition</h2>\n<p>In this section, we will create a new OpenTelemetry instrument and setup the logic to pass a measurement. </p>\n<p>References: Dynatrace documentation</p>\n<ul>\n<li><a href=\"https://docs.dynatrace.com/docs/shortlink/opentelemetry-extend-metrics\">Dynatrace OpenTelemetry Metrics</a></li>\n<li><a href=\"https://docs.dynatrace.com/docs/shortlink/opentelemetry-best-practices-metrics\">Best practices for OpenTelemetry metrics</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#supported-libraries-frameworks-application-servers-and-jvms\">Java: Supported libraries, frameworks, application servers, and JVMs</a></li>\n</ul>\n<h3 id=\"task1createanadditionalinstrument\">üìå Task #1: Create an additional instrument</h3>\n<p><strong>Your Task:</strong> Create an additional LongCounter to track attempted purchases</p>\n<p>In the file <code>order-api/src/main/java/com/dtcookie/shop/frontend/FrontendServer.java</code>, create a new LongCounter object called <code>attemptedPurchasesCounter</code> near line 43. The object should have the following properties:</p>\n<ul>\n<li>name:<code>shop.purchases.attempted</code></li>\n<li>description:<code>Attempted number of purchases</code></li>\n</ul>\n<p>Hint: This will be similar to the LongCounter objects <code>confirmedPurchasesCounter</code>, <code>expectedRevenueCounter</code>, and <code>actualRevenueCounter</code>.</p>\n<p><details>\n  <summary>Solution: Expand to copy and paste the code</summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> LongCounter attemptedPurchasesCounter = meter.counterBuilder(<span class=\"hljs-string\">&quot;shop.purchases.attempted&quot;</span>).setDescription(<span class=\"hljs-string\">&quot;Attempted number of purchases&quot;</span>).build();\n</code></pre>\n<p></details></p>\n<h3 id=\"task2createafunctiontopassameasurement\">üìå Task #2: Create a function to pass a measurement</h3>\n<p><strong>Your Task:</strong> Create a function that will pass a measurement to your instrument </p>\n<p>In the file <code>order-api/src/main/java/com/dtcookie/shop/frontend/FrontendServer.java</code>, create a new function called <code>reportAttemptedPurchases</code> after the existing functions. The function should take <code>product</code> as a parameter and increment the <code>instrument</code> tracking attemptedPurchases by 1.</p>\n<p>Hint: This will be similar to the <code>reportPurchases</code> function near line 135. </p>\n<p><details>\n  <summary>Solution: Expand to copy and paste the code</summary></p>\n<pre><code class=\"hljs java language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">reportAttemptedPurchases</span><span class=\"hljs-params\">(Product product)</span> </span>{\n        Attributes attributes = Attributes.builder()\n        .put(AttributeKey.stringKey(<span class=\"hljs-string\">&quot;product&quot;</span>), product.getName())\n        .put(AttributeKey.stringKey(<span class=\"hljs-string\">&quot;user&quot;</span>), System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>))\n        .build();\n\n        attemptedPurchasesCounter.add(<span class=\"hljs-number\">1</span>, attributes);\n    }\n</code></pre>\n<p></details></p>\n<h3 id=\"task3callthefunction\">üìå Task #3: Call the function</h3>\n<p><strong>Your Task:</strong> Add a call to the function passing the measurement</p>\n<p>In the <code>handlePlaceOrder</code> function under the call <code>reportExpectedRevenue(product);</code>, invoke the <code>reportAttemptedPurchases</code> function passing <code>product</code> as an argument.</p>\n<p>Hint: This will be similar to the <code>reportExpectedRevenue</code> function invocation. </p>\n<p><details>\n  <summary>Solution: Expand to copy and paste the code</summary></p>\n<pre><code class=\"hljs java language-java\">reportAttemptedPurchases(product);\n</code></pre>\n<p>Seen inline:</p>\n<pre><code class=\"hljs diff language-diff\">    public static String handlePlaceOrder(HttpExchange exchange) throws Exception {\n        // log.info(&quot;Placing order&quot;);\n        Product product = Product.random();\n        String productID = product.getID();\n        reportExpectedRevenue(product);\n<span class=\"hljs-addition\">+    reportAttemptedPurchases(product);</span>\n        try (Connection con = Database.getConnection(10, TimeUnit.SECONDS)) {\n            try (Statement stmt = con.createStatement()) {\n                stmt.executeUpdate(&quot;INSERT INTO orders VALUES (&quot; + productID + &quot;)&quot;);\n            }\n        }\n        validateCreditCard(product);\n        return checkInventory(product);\n    }\n</code></pre>\n<p></details></p>\n<p>After making the changes above, restart your application by running <code>docker compose up -d --build</code> in the terminal.</p>\n<h3 id=\"task4chartametric\">üìå Task #4: Chart a metric</h3>\n<p><strong>Your Task:</strong> Configure a purchases attempted vs confirmed chart</p>\n<ol>\n<li>Click on the last empty tile (bottom center) under <code>Business Analytics</code>, then the pencil icon to edit the tile.</li>\n<li>Start by naming the tile to <code>Purchases - Attempted v Confirmed</code> at the top of the right pane.</li>\n<li>Navigate to the <code>Select metric</code> dropdown, search for <code>shop.purchases.attempted</code> and select the metric.</li>\n<li>Change the <code>avg</code> aggregation dropdown to <code>sum</code>.</li>\n<li>Click on <code>Type to filter</code> and set the filter <code>user = &lt;your-github-username&gt;</code>.\nHint: To complete the step, click outside of the filter dropdown.</li>\n<li>Click on the gray <code>+</code> above <code>Run</code>, and then select <code>Metric</code> to add a second metric.</li>\n</ol>\n<p><img src=\"assets/03-03-02-add_metric.png\" alt=\"Add metric\" /></p>\n<ol start=\"7\">\n<li>Navigate to the <code>Select metric</code> dropdown for the second metric, search for <code>shop.purchases.confirmed</code> and select the metric.</li>\n<li>Change the <code>avg</code> aggregation dropdown to <code>sum</code> for the second metric.</li>\n<li>Click on <code>Type to filter</code> and set the filter <code>user = &lt;your-github-username&gt;</code> for the second metric.</li>\n<li>Click on <code>Run</code> and verify the metrics are being captured by Dynatrace by viewing the chart.</li>\n<li>Close out of the edit window of the tile.</li>\n</ol>\n<p><details>\n  <summary>Results:</summary>\n<img src=\"assets/03-02-04-complete.png\" alt=\"Tile 2\" />\n</details></p>\n<h3 id=\"optionalchallengertask\">üìå (Optional) Challenger Task</h3>\n<p><strong>Your Task:</strong> Create a new OpenTelemetry metric and chart it on the dashboard.</p>\n<hr />","activityList":[]},{"id":"3.3","name":"Davis Anomaly Detection (Alerting)\r","content":"<h2 id=\"davisanomalydetectionalerting\">Davis Anomaly Detection (Alerting)</h2>\n<p>In this section, we will create a Davis anomaly detector against one of our captured OpenTelemetry metrics.</p>\n<h3 id=\"task1createadavisanomalydetector\">üìå Task #1: Create a Davis anomaly detector</h3>\n<p>Lets create a Davis anomaly detector based off of the <code>shop.database.connections.active</code> metric. </p>\n<ol>\n<li>Navigate to the <code>Davis Anomaly Detection</code> app. </li>\n<li>Create a new detector by clicking on <code>+ Anomaly Detector</code>, then <code>Create your own Anomaly Detector</code>.</li>\n</ol>\n<p><img src=\"assets/03-03-01-new_detector.png\" alt=\"New Detector\" /></p>\n<ol start=\"3\">\n<li>Under <code>Get started</code>, set the title to <code>Shop: Connections Active</code>.</li>\n<li>Expand the <code>Configure your query</code> category. Copy/Paste the following DQL under <code>Query</code> and replace the filter with your GitHub username.</li>\n</ol>\n<pre><code class=\"hljs\">timeseries avg(shop.database.connections.active), filter:{matches<span class=\"hljs-constructor\">Value(<span class=\"hljs-params\">entityAttr</span>(<span class=\"hljs-params\">dt</span>.<span class=\"hljs-params\">entity</span>.<span class=\"hljs-params\">service</span>, <span class=\"hljs-string\">&quot;entity.name&quot;</span>)</span>, <span class=\"hljs-string\">&quot;order-backend-&lt;your-github-username&gt;&quot;</span>)}\n</code></pre>\n<ol start=\"5\">\n<li><p>Expand the <code>Customize parameters</code> category, and set the following configuration.</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Analyzers</td>\n<td><code>Static threshold anomaly detection</code></td>\n</tr>\n<tr>\n<td>Threshold</td>\n<td><code>40</code></td>\n</tr>\n<tr>\n<td>Alert condition</td>\n<td><code>Alert if metric is above</code></td>\n</tr>\n</tbody>\n</table></li>\n<li><p>Lastly, expand the <code>Create an event template</code> category and set the <code>Event name</code> to <code>High Active Database Connections</code>.</p></li>\n<li><p>Finish creating the anomaly detector by selecting <code>Create</code>.</p></li>\n</ol>\n<h3 id=\"task2chartthedavisanomalydetector\">üìå Task #2: Chart the Davis anomaly detector</h3>\n<p><strong>Your Task:</strong> Configure the active database connections anomaly detector as a tile in our dashboard.</p>\n<ol>\n<li>In the <code>Davis Anomaly Detection</code> app, find the <code>Shop: Connections Active</code> detector that was created in the previous step.</li>\n<li>Under the <code>Action</code> header on the far right of the table, select the three dots for our detector then navigate to <code>Open with</code>.</li>\n</ol>\n<p><img src=\"assets/03-03-02-open_with.png\" alt=\"Open With\" /></p>\n<ol start=\"3\">\n<li>In the <code>Open with</code> window, select <code>Dashboards</code>.</li>\n<li>Under the <code>Select destination</code> window, select your dashboard <code>Shop Application Overview</code>, then <code>Confirm</code>.</li>\n<li>At this point, you should be back in your dashboard with the new tile edit window in the right pane. Back out of the Davis AI menu by clicking on the left arrow.</li>\n</ol>\n<p><img src=\"assets/03-03-02-davis_menu.png\" alt=\"Davis Menu\" /></p>\n<ol start=\"6\">\n<li>Set the name of the tile to <code>Active Database Connections</code>.</li>\n<li>Click on <code>Run</code> to run the query.</li>\n<li>Navigate to the <code>Visual</code> tab, and expand the <code>Davis AI analysis chart</code> category.</li>\n<li>Set the <code>Visible sections</code> to <code>Chart</code>.</li>\n<li>Close out of the edit window of the tile.</li>\n<li>Move the tile to the right of <code>Order Backend Request Failures</code> by click/holding the six dots above the <code>Active Database Connections</code> tile.</li>\n</ol>\n<p><img src=\"assets/03-03-02-move.png\" alt=\"Move Tile\" /></p>\n<p><details>\n  <summary>Final Results:</summary>\n<img src=\"assets/03-03-02-complete.png\" alt=\"Tile 1\" />\n</details></p>","activityList":[]}]},{"id":"4","name":"OpenTelemetry Collector","content":"<h2 id=\"opentelemetrycollector\">OpenTelemetry Collector</h2>\n<p>üìù <strong>Reference:</strong></p>\n<ul>\n<li><a href=\"https://docs.dynatrace.com/docs/shortlink/otel-collector\">Dynatrace documentation</a></li>\n<li><a href=\"https://opentelemetry.io/docs/collector/getting-started/\">OpenTelemetry documentation</a> </li>\n</ul>\n<p>In this section of the hands on, we will cover the following</p>\n<ol>\n<li>Basic configuration</li>\n<li>Configuration for transforming received metrics</li>\n<li>Configuration for OpenTelemetry logs</li>\n</ol>\n<p><br /></p>\n<hr/>\n<blockquote>\n  <p>üí° <strong>Hint:</strong> If you got lost in the previous section executing the command below will take care of everything</p>\n</blockquote>\n<pre><code class=\"hljs\">docker compose down <span class=\"hljs-variable\">&amp;&amp;</span> git <span class=\"hljs-meta\">reset</span> --hard <span class=\"hljs-variable\">&amp;&amp;</span> git checkout metrics-finished\n</code></pre>","activityList":[{"id":"4.1","name":"Basic configuration\r","content":"<h2 id=\"basicconfiguration\">Basic configuration</h2>\n<h3 id=\"task1pipelines\">üìå Task 1: Pipelines</h3>\n<p>Configure the traces and metrics service pipelines</p>\n<p>You can find <mark><strong>otel-collector-config.yaml</strong> </mark> in the directory</p>\n<pre><code class=\"hljs\">collector/otel-collector-<span class=\"hljs-built_in\">config</span>.yaml\n</code></pre>\n<p>Scroll down to the section called <code>service</code>. Make the necessary changes to activate the <code>traces</code> and <code>metrics</code> pipelines.</p>\n<p>For the metrics pipeline enable the pre-configured processors <code>metricstransform</code> and <code>filter</code>.</p>\n<p><details>\n  <summary>Expand to see solution</summary></p>\n<h4> For the traces pipeline </h4>\n<pre><code class=\"hljs yaml language-yaml\">    <span class=\"hljs-attr\">traces:</span>\n      <span class=\"hljs-attr\">receivers:</span> [<span class=\"hljs-string\">otlp</span>]\n      <span class=\"hljs-attr\">processors:</span> [<span class=\"hljs-string\">batch</span>]\n      <span class=\"hljs-attr\">exporters:</span> [<span class=\"hljs-string\">debug</span>, <span class=\"hljs-string\">otlphttp</span>]\n</code></pre>\n<h4> For the metrics pipeline </h4>\n<pre><code class=\"hljs yaml language-yaml\">    <span class=\"hljs-attr\">metrics:</span>\n      <span class=\"hljs-attr\">receivers:</span> [<span class=\"hljs-string\">otlp</span>]\n      <span class=\"hljs-attr\">processors:</span> [<span class=\"hljs-string\">batch</span>, <span class=\"hljs-string\">metricstransform</span>, <span class=\"hljs-string\">filter</span>]\n      <span class=\"hljs-attr\">exporters:</span> [<span class=\"hljs-string\">debug</span>, <span class=\"hljs-string\">otlphttp</span>]\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: If you are copying the text above, be careful of spaces and tabs in a yaml file. If in doubt, check the original file in the github repo and copy the spacing from the original file.</p>\n</blockquote>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"task2configureexporters\">üìå Task 2: Configure exporters</h3>\n<p>Reroute OpenTelemetry exporters to the OpenTelemetry collector</p>\n<p>The <mark><strong>OTEL<em>EXPORTER</em>OTLP_ENDPOINT</strong> </mark> environment variable will send <strong><em>all OpenTelemetry signals</em></strong> via OTLP (i.e. traces, metrics and logs) to the specified endpoint, without the need to configure each of them separately.</p>\n<pre><code class=\"hljs bash language-bash\">OTEL_EXPORTER_OTLP_ENDPOINT=http://opentelemetry-collector:4318\n</code></pre>\n<h4 id=\"orderapiservice\">order-api service</h4>\n<p>The <mark><strong>Dockerfile</strong></mark> can be found in</p>\n<pre><code class=\"hljs\"><span class=\"hljs-attribute\"><span class=\"hljs-nomarkup\">order</span></span>-api/Dockerfile\n</code></pre>\n<ol>\n<li>edit the dockerfile</li>\n<li>uncomment line <code>33</code> to enable the collector endpoint</li>\n<li>comment line <code>45</code> and <code>46</code> to disable the Dynatrace URL endpoint</li>\n</ol>\n<h4 id=\"orderbackendservice\">order-backend service</h4>\n<p>The <mark><strong>Dockerfile</strong></mark> can be found in</p>\n<pre><code class=\"hljs\"><span class=\"hljs-attribute\"><span class=\"hljs-nomarkup\">order</span></span>-backend/Dockerfile\n</code></pre>\n<ol>\n<li>edit the dockerfile</li>\n<li>uncomment line <code>45</code> to enable the collector endpoint</li>\n<li>comment line <code>34</code>, <code>35</code>, <code>41</code>, <code>42</code> to disable the Dynatrace URL endpoint</li>\n</ol>\n<h4 id=\"rebuildthecontainers\">Rebuild the containers</h4>\n<p>For the OpenTelemetry Collector, you will need to completely stop and remove all containers. To do so, run the command</p>\n<pre><code class=\"hljs bash language-bash\">docker compose down\n</code></pre>\n<p>Once all the containers are stopped, run the <code>compose up</code> command again.</p>\n<pre><code class=\"hljs bash language-bash\">docker compose up -d --build\n</code></pre>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<h4 id=\"validatingusingthedockerlogsoftheopentelemetrycollector\">Validating using the docker logs of the OpenTelemetry collector</h4>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector -f\n</code></pre>\n<p>You will notice a stream of data, esp. items like <code>trace</code>, <code>metrics</code></p>\n<p>Filter the output for a specific string, example validating which exporters are activate</p>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector 2&gt;&amp;1 | grep -i exporter\n</code></pre>\n<p>Expected output</p>\n<pre><code class=\"hljs bash language-bash\">2024-12-20T12:30:34.590Z        info    builders/builders.go:26 Development component. May change <span class=\"hljs-keyword\">in</span> the future.        {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;exporter&quot;</span>, <span class=\"hljs-string\">&quot;data_type&quot;</span>: <span class=\"hljs-string\">&quot;metrics&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;debug&quot;</span>}\n2024-12-20T12:30:34.591Z        info    builders/builders.go:26 Development component. May change <span class=\"hljs-keyword\">in</span> the future.        {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;exporter&quot;</span>, <span class=\"hljs-string\">&quot;data_type&quot;</span>: <span class=\"hljs-string\">&quot;traces&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;debug&quot;</span>}\n</code></pre>\n<h4 id=\"validatingindynatrace\">Validating in Dynatrace</h4>\n<ul>\n<li>Launch the <code>Distributed trace</code> app to validate if you are still receving traces with the latest timestamps</li>\n<li>Launch a <code>Notebook</code> or <code>Dashboard</code> app, use the <code>Metric explorer</code> to search for the <code>jvm</code> metrics</li>\n<li>What do you notice about the metrics? <strong><em>Hint:</em></strong> look at the metric names‚Ä¶</li>\n</ul>\n<h3 id=\"troubleshootingtips\">üí° Troubleshooting tips</h3>\n<p>Check log output of the OpenTelemetry collector container for any errors or items not starting etc.</p>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector\n</code></pre>","activityList":[]},{"id":"4.2","name":"Transform metrics\r","content":"<h2 id=\"transformmetrics\">Transform metrics</h2>\n<p>üìù <strong>References</strong></p>\n<ul>\n<li><a href=\"https://docs.dynatrace.com/docs/shortlink/otel-collector#which-distribution-should-i-use\">Which distribution should I use?</a></li>\n<li><a href=\"https://docs.dynatrace.com/docs/ingest-from/opentelemetry/collector/use-cases\">Various use cases</a> </li>\n<li><a href=\"https://docs.dynatrace.com/docs/ingest-from/opentelemetry/getting-started/metrics/ingest/migration-guide-otlp-exporter#in-collector-additional-features\">Adding a prefix to metrics</a></li>\n</ul>\n<p>Open the file <mark><strong>otel-collector-config.yaml</strong> </mark> in the directory </p>\n<pre><code class=\"hljs\">collector/otel-collector-<span class=\"hljs-built_in\">config</span>.yaml\n</code></pre>\n<h3 id=\"addaprefixtoyourmetrics\">Add a prefix to your metrics</h3>\n<p>Scroll down to the section called <code>processors</code>, under <code>metricstransform</code>. You will see the definition</p>\n<pre><code class=\"hljs yaml language-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">include:</span> <span class=\"hljs-string\">^jvm\\.(.*)$$</span>\n  <span class=\"hljs-attr\">match_type:</span> <span class=\"hljs-string\">regexp</span>\n  <span class=\"hljs-attr\">action:</span> <span class=\"hljs-string\">update</span>\n  <span class=\"hljs-attr\">new_name:</span> <span class=\"hljs-string\">${GITHUB_USER}.otel.jvm.$${1}</span>\n</code></pre>\n<p>This section tells the collector to use <code>regex</code> as a matcher and updates all metric names that starts with <code>jvm</code>, with a prefix of <code>GITHUB_USER.otel</code>. You can manipulate the regex to match different criteria, for example</p>\n<pre><code class=\"hljs yaml language-yaml\"><span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">include:</span> <span class=\"hljs-string\">^shop\\.(.*)$$</span>\n  <span class=\"hljs-attr\">match_type:</span> <span class=\"hljs-string\">regexp</span>\n  <span class=\"hljs-attr\">action:</span> <span class=\"hljs-string\">update</span>\n  <span class=\"hljs-attr\">new_name:</span> <span class=\"hljs-string\">${GITHUB_USER}.otel.shop.$${1}</span>\n</code></pre>\n<p>would allow you to modify only metric names that starts with <code>shop</code>, and update it with a prefix of <code>GITHUB_USER.otel</code>.</p>\n<h3 id=\"manipulatefilters\">Manipulate filters</h3>\n<p>Scroll down to the section called <code>processors</code>, under <code>filters</code>. You will see the definition</p>\n<pre><code class=\"hljs yaml language-yaml\">  <span class=\"hljs-attr\">filter:</span>\n    <span class=\"hljs-attr\">metrics:</span>\n      <span class=\"hljs-attr\">exclude:</span>\n        <span class=\"hljs-attr\">match_type:</span> <span class=\"hljs-string\">regexp</span>\n        <span class=\"hljs-attr\">metric_names:</span>\n          <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">.*\\.jvm.class*</span>\n</code></pre>\n<p>This section tells the collector to use <code>regex</code> as a matcher and <mark>excludes</mark> all metrics containing the words <code>.jvm.class</code>. You can manipulate the regex to match different criteria.</p>\n<h3 id=\"task1\">üìå Task 1</h3>\n<p><details>\n  <summary> üìå Add prefix to <mark>all ingested</mark> OpenTelemetry metrics. Expand to see solution.</summary></p>\n<pre><code class=\"hljs yaml language-yaml\">      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">include:</span> <span class=\"hljs-string\">^(.*)$$</span>\n        <span class=\"hljs-attr\">match_type:</span> <span class=\"hljs-string\">regexp</span>\n        <span class=\"hljs-attr\">action:</span> <span class=\"hljs-string\">update</span>\n        <span class=\"hljs-attr\">new_name:</span> <span class=\"hljs-string\">${GITHUB_USER}.otel.$${1}</span>\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: If you are copying the text above, please be careful of the intendation. Please follow the preceding definitions if unsure.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<h3 id=\"task2\">üìå Task 2</h3>\n<p><details>\n  <summary> üìå Filter out all <mark>jvm metrics</mark>. Expand to see solution.</summary></p>\n<pre><code class=\"hljs yaml language-yaml\">  <span class=\"hljs-attr\">filter:</span>\n    <span class=\"hljs-attr\">metrics:</span>\n      <span class=\"hljs-attr\">exclude:</span>\n        <span class=\"hljs-attr\">match_type:</span> <span class=\"hljs-string\">regexp</span>\n        <span class=\"hljs-attr\">metric_names:</span>\n          <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">.*\\.jvm.*</span>\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: If you are copying the text above, please be careful of the intendation. Please follow the preceding definitions if unsure.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<h3 id=\"rebuildthecontainers\">Rebuild the containers</h3>\n<p>For the OpenTelemetry Collector, you will need to completely stop and remove all containers. To do so, run the command</p>\n<pre><code class=\"hljs bash language-bash\">docker compose down\n</code></pre>\n<p>Once all the containers are stopped, run the <code>compose up</code> command again.</p>\n<pre><code class=\"hljs bash language-bash\">docker compose up -d --build\n</code></pre>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<p>Validate <code>metricstransform</code></p>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector 2&gt;&amp;1 | grep -i <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${GITHUB_USER}</span>.otel.&quot;</span>\n</code></pre>\n<p>Expected output: list of metric names matching <code>${GITHUB_USER}.otel.*</code></p>\n<p>Validate <code>filter</code></p>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector 2&gt;&amp;1 | grep -i filter\n</code></pre>\n<p>Expected output:</p>\n<pre><code class=\"hljs bash language-bash\">2024-12-20T12:55:18.711Z        info    filterprocessor@v0.116.0/metrics.go:99  Metric filter configured        {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;processor&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;filter&quot;</span>, <span class=\"hljs-string\">&quot;pipeline&quot;</span>: <span class=\"hljs-string\">&quot;metrics&quot;</span>, <span class=\"hljs-string\">&quot;include match_type&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>, <span class=\"hljs-string\">&quot;include expressions&quot;</span>: [], <span class=\"hljs-string\">&quot;include metric names&quot;</span>: [], <span class=\"hljs-string\">&quot;include metrics with resource attributes&quot;</span>: null, <span class=\"hljs-string\">&quot;exclude match_type&quot;</span>: <span class=\"hljs-string\">&quot;regexp&quot;</span>, <span class=\"hljs-string\">&quot;exclude expressions&quot;</span>: [], <span class=\"hljs-string\">&quot;exclude metric names&quot;</span>: [<span class=\"hljs-string\">&quot;(.*)\\\\.otel.jvm.*&quot;</span>], <span class=\"hljs-string\">&quot;exclude metrics with resource attributes&quot;</span>: null}\n</code></pre>\n<ul>\n<li>Launch a <code>Notebook</code> or <code>Dashboard</code> app, use the <code>Metric explorer</code> to search for the metrics</li>\n</ul>\n<h3 id=\"troubleshootingtips\">üí° Troubleshooting tips</h3>\n<p>Check log output of the OpenTelemetry collector container</p>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector\n</code></pre>","activityList":[]},{"id":"4.3","name":"Prepare for logs\r","content":"<h2 id=\"prepareforlogs\">Prepare for logs</h2>\n<h3 id=\"taskconfiguretheservicepipelines\">üìå Task Configure the service pipelines</h3>\n<p>Apply what you have learnt and configure a new service pipeline for logs.</p>\n<p>You can find <mark><strong>otel-collector-config.yaml</strong> </mark> in the directory</p>\n<pre><code class=\"hljs\">collector/otel-collector-<span class=\"hljs-built_in\">config</span>.yaml\n</code></pre>\n<p>Scroll down to the section called <code>service</code> and make the necessary modifications. Be careful of the spaces as yaml files are sensitive to the spaces.</p>\n<p><details>\n  <summary>Expand to see solution</summary></p>\n<pre><code class=\"hljs yaml language-yaml\">    <span class=\"hljs-attr\">logs:</span>\n      <span class=\"hljs-attr\">receivers:</span> [<span class=\"hljs-string\">otlp</span>]\n      <span class=\"hljs-attr\">processors:</span> [<span class=\"hljs-string\">batch</span>]\n      <span class=\"hljs-attr\">exporters:</span> [<span class=\"hljs-string\">debug</span>, <span class=\"hljs-string\">otlphttp</span>]\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<pre><code class=\"hljs bash language-bash\">docker logs opentelemetry-collector 2&gt;&amp;1 | grep -i logs\n</code></pre>\n<p>Expected output</p>\n<pre><code class=\"hljs bash language-bash\">2024-12-20T12:55:18.701Z        info    builders/builders.go:26 Development component. May change <span class=\"hljs-keyword\">in</span> the future.        {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;exporter&quot;</span>, <span class=\"hljs-string\">&quot;data_type&quot;</span>: <span class=\"hljs-string\">&quot;logs&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;debug&quot;</span>}\n2024-12-20T12:55:24.534Z        info    Logs    {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;exporter&quot;</span>, <span class=\"hljs-string\">&quot;data_type&quot;</span>: <span class=\"hljs-string\">&quot;logs&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;debug&quot;</span>, <span class=\"hljs-string\">&quot;resource logs&quot;</span>: 1, <span class=\"hljs-string\">&quot;log records&quot;</span>: 2}\n        {<span class=\"hljs-string\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;exporter&quot;</span>, <span class=\"hljs-string\">&quot;data_type&quot;</span>: <span class=\"hljs-string\">&quot;logs&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;debug&quot;</span>}\n</code></pre>","activityList":[]}]},{"id":"5","name":"Ingesting logs via OpenTelemetry\r","content":"<h2 id=\"ingestinglogsviaopentelemetry\">Ingesting logs via OpenTelemetry</h2>\n<blockquote>\n  <p>üí° <strong>Hint:</strong> If you got lost in the previous section executing the command below will take care of everything</p>\n</blockquote>\n<pre><code class=\"hljs\">docker compose down <span class=\"hljs-variable\">&amp;&amp;</span> git <span class=\"hljs-meta\">reset</span> --hard <span class=\"hljs-variable\">&amp;&amp;</span> git checkout collector-finished\n</code></pre>\n<p><br /></p>\n<hr/>\n<p>üìù <strong>Reference:</strong> Dynatrace documentation <a href=\"https://docs.dynatrace.com/docs/shortlink/otel-overview-logs\">OpenTelemetry Logs</a></p>\n<h3 id=\"task\">üìå Task</h3>\n<p><strong>Task 1:</strong> Enable Java environment variables for the Backend server Java Otel logs exporter. File name is <mark><strong>Dockerfile</strong></mark></p>\n<p>The file can be found in</p>\n<pre><code class=\"hljs\"><span class=\"hljs-attribute\"><span class=\"hljs-nomarkup\">order</span></span>-backend/Dockerfile\n</code></pre>\n<ol>\n<li>Remove the comments on lines <code>48</code> and <code>49</code>.</li>\n<li>Rebuild the containers by running <code>docker compose up -d --build</code></li>\n</ol>\n<p>The final <mark>Dockerfile</mark> should look like this.</p>\n<pre><code class=\"hljs bash language-bash\">ENV OTEL_LOGS_EXPORTER=otlp\nENV OTEL_EXPORTER_OTLP_LOGS_PROTOCOL=http/protobuf\n</code></pre>\n<p><strong>Optional:</strong> Enable log appenders in <mark><strong>log4j2.xml</strong></mark></p>\n<p>The file can be found in</p>\n<pre><code class=\"hljs\"><span class=\"hljs-attribute\">src</span>/main/resources/log<span class=\"hljs-number\">4</span>j<span class=\"hljs-number\">2</span>.xml\n</code></pre>\n<p>The configuration for log4j is goverened in the xml resource file. This is useful when using manual instrumentation and it can help insert the traceid and spanid without much programming effort for those Java codes where manual insturmentation is done.</p>\n<p>This step here is optional because we are using the auto instrumentation on this Java service and many items are taken care by the auto instrumentation agent.</p>\n<ol>\n<li>Remove the comments on line 7.</li>\n<li>Remove the comments on line 16.</li>\n</ol>\n<p>The final <mark><strong>log4j2.xml</strong></mark> should look like this.</p>\n<p><img src=\"assets/05-task1-logappender.png\" alt=\"Task1\" /></p>\n<p>In case the log4j file is messed up, here is the working code that you can copy. </p>\n<p><details>\n  <summary>Expand to copy the contents</summary></p>\n<pre><code class=\"hljs xml language-xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Configuration</span> <span class=\"hljs-attr\">packages</span>=<span class=\"hljs-string\">&quot;io.opentelemetry.instrumentation.log4j.appender.v2_17&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Appenders</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Console</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;Console&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PatternLayout</span> <span class=\"hljs-attr\">pattern</span>=<span class=\"hljs-string\">&quot;[%d{HH:mm:ss}] [%-5level] [%c{1}] %msg %throwable{short} %n&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Console</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">OpenTelemetry</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;OpenTelemetry&quot;</span> <span class=\"hljs-attr\">captureMapMessageAttributes</span>=<span class=\"hljs-string\">&quot;true&quot;</span> <span class=\"hljs-attr\">captureExperimentalAttributes</span>=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">File</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;File&quot;</span> <span class=\"hljs-attr\">fileName</span>=<span class=\"hljs-string\">&quot;logs/hotday-${env:DEMO_PURPOSE}.log&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PatternLayout</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Pattern</span>&gt;</span>[%d{HH:mm:ss}] [%-5level] [%c{1}] %msg %throwable{short}%n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Pattern</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">PatternLayout</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">File</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Appenders</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Loggers</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Root</span> <span class=\"hljs-attr\">level</span>=<span class=\"hljs-string\">&quot;trace&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppenderRef</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&quot;OpenTelemetry&quot;</span> /&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppenderRef</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&quot;Console&quot;</span> /&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppenderRef</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&quot;File&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Root</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Loggers</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Configuration</span>&gt;</span>\n</code></pre>\n<p></details></p>\n<h3 id=\"verifyresults\">‚úÖ Verify Results</h3>\n<p>You should start receiving logs in Dynatrace.</p>\n<ul>\n<li>Navigate to <strong>Dynatrace menu > logs</strong></li>\n<li>The log viewer should start populating with logs</li>\n</ul>","activityList":[]},{"id":"6","name":"Project Capstone (bonus)\r","content":"<h2 id=\"projectcapstonebonus\">Project Capstone (bonus)</h2>\n<blockquote>\n  <p>üí° <strong>Hint:</strong> If you got lost in the previous section executing the command below will take care of everything</p>\n</blockquote>\n<pre><code class=\"hljs\">docker compose down <span class=\"hljs-variable\">&amp;&amp;</span> git <span class=\"hljs-meta\">reset</span> --hard <span class=\"hljs-variable\">&amp;&amp;</span> git checkout logs-finished\n</code></pre>\n<p><br /></p>\n<hr/>\n<p><em>Capstone (noun) [Ààkap-Àåst≈çn]</em></p>\n<ul>\n<li>the high point</li>\n<li>crowning achievement</li>\n</ul>\n<h3 id=\"whythissection\">Why this section?</h3>\n<p>Your Demo Application has one remaining secret to reveal. And we've kept it for the end of that topic for those students who want to get challenged today.</p>\n<p>We named this <strong><em>Project Capstone</em></strong> because after completing this section, you can congratulate yourself for being able to grasp the core concepts of OpenTelemetry and what is required to implement it in your environment.</p>\n<p>This section is a <strong>bonus</strong> section and is optional. You can always revisit this section of the lab anytime.</p>\n<h3 id=\"whatisprojectcapstoneabout\">What is Project Capstone about?</h3>\n<ul>\n<li>Helps you to apply the core concepts of OpenTelemetry traces, metrics and logs</li>\n<li>It can be broken down into 3 sections, and each section builds up your knoweldge on the following topics:</li>\n<li>Auto instrumentation of a Python service to receive baseline observability signals.</li>\n<li>Implement Trace Context Propagation to link traces between Java and Python service.</li>\n<li>Tests your knowledge on where to capture data for added visibility.</li>\n</ul>\n<p>There is only a dependency on the first section, meaning that you need to be able to receive a baseline of observability signals before you attempt section 2 and 3. However, section 2 and 3 are mutually exclusive of each other, meaning that you can attempt section 3 without completing section 2 and vice versa. </p>\n<h3 id=\"scenario\">Scenario</h3>\n<ul>\n<li>A team has been formed to create a service to produce quotes.</li>\n<li>The team decided on using Python Flask to build the business logic.</li>\n<li>This services will be called by the Java application and is flexible to extended anytime.</li>\n<li>For now, the Java Backend service will be the only service making a http call to the python service. </li>\n</ul>","activityList":[{"id":"6.1","name":"Receiving basic observability signals\r","content":"<h2 id=\"receivingbasicobservabilitysignals\">Receiving basic observability signals</h2>\n<h3 id=\"references\">üìë References</h3>\n<ul>\n<li><a href=\"https://opentelemetry.io/docs/concepts/instrumentation/zero-code\">Zero-code instrumentation</a></li>\n<li><a href=\"https://opentelemetry.io/docs/zero-code/python/\">Python Zero-code reference</a></li>\n</ul>\n<h3 id=\"filestructure\">üìë File structure</h3>\n<ul>\n<li>the directory <code>order-quotes</code> contain all the python codes</li>\n<li><code>main.py</code> is the main python progam</li>\n<li><code>utils.py</code> is the a sub python program that is called by main</li>\n<li><code>Dockerfile</code> is the file to dockerize the running of the python application. It contains the environment variables, installing the required python packages, start sequence etc.</li>\n<li><code>requirements.txt</code> is the required python packages</li>\n</ul>\n<h3 id=\"yourtaskdeploytheopentelemetryzerocodeinsturmentation\">üìå Your Task: Deploy the OpenTelemetry zero code insturmentation</h3>\n<p>Some <strong><em>hints</em></strong></p>\n<ul>\n<li>You will only need to modify <code>Dockerfile</code>.</li>\n<li>A few key considerations:<ul>\n<li>Installing the auto instrumentation agent package (this has already been done for you).</li>\n<li>Setting up the OTLP exporters for the various signals (traces, metrics, logs).</li>\n<li>Configuring additional environment variables.</li>\n<li>Starting the auto-insturmentation with the python program.</li></ul></li>\n<li>Once you are done modifying the files, rebuild by running <code>docker compose up -d --build</code></li>\n</ul>\n<p><details>\n<summary><strong>Expand for solution</strong></summary></p>\n<p>The Dockerfile should contain these environment variables in order to receive traces, metrics and logs from the Python service.</p>\n<pre><code class=\"hljs properties language-properties\"><span class=\"hljs-comment\">## Python will require gRPC</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_EXPORTER_OTLP_ENDPOINT=http://opentelemetry-collector:4317</span>\n<span class=\"hljs-comment\">\n## setup for traces</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_SERVICE_NAME=order-quotes-${GITHUB_USER}</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_TRACES_EXPORTER=otlp</span>\n<span class=\"hljs-comment\">\n## setup for metrics</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE=DELTA</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_METRICS_EXPORTER=otlp</span>\n<span class=\"hljs-comment\">\n## setup for logs exporter and logging</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_LOGS_EXPORTER=otlp</span>\n<span class=\"hljs-attr\">ENV</span> <span class=\"hljs-string\">OTEL_PYTHON_LOGGING_AUTO_INSTRUMENTATION_ENABLED=true</span>\n<span class=\"hljs-comment\">\n## Start auto-instrumentation</span>\n<span class=\"hljs-attr\">ENTRYPOINT</span> <span class=\"hljs-string\">[&quot;sh&quot;, &quot;-c&quot;, &quot;opentelemetry-instrument python order-quotes/main.py&quot;]</span>\n</code></pre>\n<p></details></p>\n<p></br></p>\n<p>üí° Questions\n<details><summary> üí° What happens when you don't set <mark>OTEL<em>EXPORTER</em>OTLP<em>METRICS</em>TEMPORALITY_PREFERENCE=DELTA`</mark>? </summary> Dynatrace will not ingest the metrics and the Otel collector will register that the metrics has been dropped.</details>\n<details><summary> üí° Where can you see that the Otel collector is dropping the metrics? </summary></p>\n<p>Collector logs. You can get the logs by running this command</p>\n<pre><code class=\"hljs sh language-sh\">docker logs opentelemetry-collector 2&gt;&amp;1 | grep -i dropped\n</code></pre>\n<p>If you had enabled it eariler, disable it, do a docker compose down to shutdown everything and start the apps up again to understand the impact.</p>\n<p></details></p>\n<p><br></p>\n<h3 id=\"verifyresults\">‚úÖ Verify Results</h3>\n<ol>\n<li>Validate that you are receiving the new Python <code>traces</code> in Dynatrace<ul>\n<li>Open <code>Distributed trace</code> app</li>\n<li>Filter and search for the Python service <code>order-quotes-(your github username)</code></li></ul></li>\n<li>Validate that you are receiving <code>logs</code> from the new Python service<ul>\n<li>Open <code>Logs</code> app</li>\n<li>Use the <code>service.name</code> and search for <code>order-quotes-(your github username)</code></li></ul></li>\n<li>Validate that you are receiving <code>metrics</code> from the Python auto instrumentation<ul>\n<li>Open <code>Notebooks</code> app</li>\n<li>Explore <code>metrics</code> and search for python, you should see metric names that contain python</li>\n<li>If you had implemented the renaming of all metrics in the Collector, these metrics will now also contain your GitHub user name.otel </li></ul></li>\n</ol>","activityList":[]},{"id":"6.2","name":"Implement Trace Context Propagation\r","content":"<h2 id=\"implementtracecontextpropagation\">Implement Trace Context Propagation</h2>\n<h3 id=\"introduction\">Introduction</h3>\n<p>You do not need to complete this section before attempting the next section as these 2 are mutually exclusive. If you are stuck here, you can attempt the next section and revisit this one anytime.</p>\n<p>The \"Processing Backend\" is getting called via HTTP GET Request from your Backend Server - just not in a way that Auto Instrumentation is able to recognize that.</p>\n<h3 id=\"yourtaskmakeoutgoinghttprequestsvisible\">üìå Your Task: Make outgoing HTTP Requests visible</h3>\n<p>Open up <code>order-backend/src/main/java/com/dtcookie/shop/backend/BackendServer.java</code>.</p>\n<p>Find a method named <code>notifyProcessingBackend</code>. The usage <code>GETRequest</code> clearly hints, that an outgoing HTTP request is happening here</p>\n<ul>\n<li>Ensure that the Trace Context is getting propagated.</li>\n<li>Libraries that represent an exit point from an application, in our case, HTTP clients, should <strong><em>inject</em></strong> context into outgoing messages</li>\n<li>You may want to take another look into the lab guide for <code>Span Creation</code> for an example, as well as using <a href=\"https://opentelemetry.io/docs/languages/java/api/#contextpropagators\">OpenTelemetry documentation context propagators</a> to understand the concepts with sample code.</li>\n<li>As <code>GETRequest</code> has been designed by the Java coder and not a known Java class/framework, you might need to understand how that class is built before you can figure out how to introduce the necessary code.</li>\n<li>Some hints to help you out‚Ä¶</li>\n<li><code>GETRequest</code>already has the TextMapSetter defined, and it is on line <code>38</code> of <mark>common/src/main/java/com/dtcookie/util/GETRequest.java</mark></li>\n<li>You will only need to call the ContextPropagators instance, and inject the current context into the GETRequest carrier, together with the TextMapSetter.</li>\n</ul>\n<p>Some things to consider‚Ä¶\n<details>\n    <summary> üí° Would the Java auto instrumentation create additional spans for you in order-backend to indicate that notifyProcessingBackend is making a call to an external service? If no, why?</summary>\nThe Java auto instrumentation will not create additional spans as notifyProcessingBackend method/function call is not from any of the known auto instrumentation frameworks. \n</details>\n<details>\n    <summary> üí° Following the above consideration, would there be a need to create a custom OpenTelemetry Span? Why?</summary>\nTechnicall, if you are just concern in connecting the services together, there is no need to create a custom span. However, in terms of having clear indication of where one service starts and where the other begins, without a custom span, it is difficult to understand which part of your application makes that call. Even more so when the call fails, there will not be any indication on which method has failed. Thus making diagnostics difficult.\n</details></p>\n<p><br/></p>\n<p>We highly recommend that you enrich the method with a custom OpenTelemetry Span, and if you are attempting it, ensure that</p>\n<ul>\n<li>You are using the correct Span Kind</li>\n<li>You add semantic attributes. HTTP<em>METHOD and HTTP</em>URL will be sufficient for Dynatrace.</li>\n<li>You handle exceptions properly in case the outgoing call fails</li>\n</ul>\n<p><details>\n<summary><strong>Expand for solution (without custom span creation)</strong></summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notifyProcessingBackend</span><span class=\"hljs-params\">(Product product)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    GETRequest request = <span class=\"hljs-keyword\">new</span> GETRequest(<span class=\"hljs-string\">&quot;http://order-quotes-&quot;</span> + System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>) + <span class=\"hljs-string\">&quot;:&quot;</span> + <span class=\"hljs-string\">&quot;8090/quote&quot;</span>);\n    openTelemetry.getPropagators().getTextMapPropagator().inject(Context.current(), request, GETRequest.OTEL_SETTER);\n    request.send();\n}\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<p><details>\n<summary><strong>Expand for solution (with custom span creation)</strong></summary></p>\n<pre><code class=\"hljs java language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notifyProcessingBackend</span><span class=\"hljs-params\">(Product product)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n    String call = <span class=\"hljs-string\">&quot;http://order-quotes-&quot;</span> + System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>) + <span class=\"hljs-string\">&quot;:&quot;</span> + <span class=\"hljs-string\">&quot;8090/quote&quot;</span>;\n    Span outGoing = tracer.spanBuilder(<span class=\"hljs-string\">&quot;/GET order-quotes python service&quot;</span>).setSpanKind(SpanKind.CLIENT).startSpan();\n    GETRequest request = <span class=\"hljs-keyword\">new</span> GETRequest(<span class=\"hljs-string\">&quot;http://order-quotes-&quot;</span> + System.getenv(<span class=\"hljs-string\">&quot;GITHUB_USER&quot;</span>) + <span class=\"hljs-string\">&quot;:&quot;</span> + <span class=\"hljs-string\">&quot;8090/quote&quot;</span>);\n    <span class=\"hljs-keyword\">try</span> (Scope scope = outGoing.makeCurrent()) {\n      outGoing.setAttribute(SemanticAttributes.HTTP_METHOD, <span class=\"hljs-string\">&quot;GET&quot;</span>);\n      outGoing.setAttribute(SemanticAttributes.HTTP_URL, call);\n      openTelemetry.getPropagators().getTextMapPropagator().inject(Context.current(), request, GETRequest.OTEL_SETTER);\n\n      <span class=\"hljs-comment\">// Make outgoing call</span>\n      request.send();\n    } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n      outGoing.setAttribute(SemanticAttributes.HTTP_RESPONSE_STATUS_CODE, <span class=\"hljs-number\">500</span>);\n      outGoing.recordException(e);\n      outGoing.setStatus(StatusCode.ERROR);\n      <span class=\"hljs-keyword\">throw</span> e;\n    } <span class=\"hljs-keyword\">finally</span> {\n      outGoing.end();\n    }\n}\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h3 id=\"verifyresults\">‚úÖ Verify results</h3>\n<ul>\n<li>Restart your Demo Application</li>\n<li>Open up a recent <code>/place-order</code> trace</li>\n<li>Validate that the Backend Server indeed shows an outgoing HTTP call to the Python Service</li>\n</ul>","activityList":[]},{"id":"6.3","name":"Enhance visibility\r","content":"<h2 id=\"enhancevisibility\">Enhance visibility</h2>\n<h3 id=\"additionaldetailsinlogs\">Additional details in logs</h3>\n<ul>\n<li><code>utils.py</code> is programed to throw an exception whenever the number n &gt;= 20 (look at line <code>13</code> and <code>14</code>).</li>\n<li>An exception handler has been programed and we have logged a simple string message on line <code>29</code>.</li>\n<li>If you noticed, the log is at <strong><em>\"WARN\"</em></strong> level.</li>\n</ul>\n<h4 id=\"yourtask\">üìå Your Task</h4>\n<ul>\n<li>Enhance the logs in <code>utils.py</code> so that is at <strong><em>exception</em></strong> level rather than warn, reference: <a href=\"https://www.geeksforgeeks.org/how-to-log-a-python-exception/\">How to log a Python exception?</a></li>\n<li>Ensure that the offending <strong><em>value of n</em></strong> that causes the exception is logged as well.</li>\n<li>You only need to modify  <code>utils.py</code>.</li>\n<li>Remember to rebuild the application after any modifications <code>docker compose up -d --build</code>.</li>\n</ul>\n<p><details>\n<summary><strong>Expand for solution</strong></summary></p>\n<pre><code class=\"hljs diff language-diff\">def process(n: int) -&gt; int:\n    with tracer.start_as_current_span(&quot;process&quot;) as span:\n        try:\n            f = fibonacci(n)\n            return f\n        except Exception as e:\n<span class=\"hljs-addition\">+           logging.getLogger().exception(n)</span>\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: Do not copy the + character</p>\n</blockquote>\n<p>Or more elegantly,</p>\n<pre><code class=\"hljs python language-python\">logging.getLogger().exception(<span class=\"hljs-string\">&quot;SeedNumber=%s&quot;</span>,n)\n</code></pre>\n<p></details></p>\n<p><br/></p>\n<h4 id=\"verifyresults\">‚úÖ Verify Results</h4>\n<ol>\n<li>Open <code>Logs</code> app</li>\n<li>Filter the log entries for service.name order-quotes-(replace with your github name)</li>\n</ol>\n<p><details>\n<summary>üí° What do you notice of the difference in log levels?</summary>\nLogs with WARN status are very basic and outputs whatever text that was programmed there, whereas logs with ERROR status contain more details.\n</details>\n</br></p>\n<p><details>\n<summary>üí° What additional details are included?</summary>\nThe exception details are automatically appended to the logs.\n</details></p>\n<p><br/></p>\n<h3 id=\"exceptionsinspans\">Exceptions in spans</h3>\n<ul>\n<li>Besides logging, we can also enhance spans to capture the exceptions.</li>\n<li>Clearly, an exception is thrown and we want the spans to also reflect those exceptions and mark that specific span as \"failed\".</li>\n</ul>\n<h4 id=\"yourtask-1\">üìå Your Task</h4>\n<ul>\n<li>Modify <code>utils.py</code> to record exceptions in spans</li>\n<li><strong><em>hint</em></strong>: <a href=\"https://opentelemetry.io/docs/languages/python/instrumentation/#record-exceptions-in-spans\">OpenTelemetry python documentation</a></li>\n<li>Remember to rebuild the application after any modifications <code>docker compose up -d --build</code>.</li>\n</ul>\n<p><details>\n<summary><strong>Expand for solution</strong></summary></p>\n<pre><code class=\"hljs diff language-diff\">def process(n: int) -&gt; int:\n    with tracer.start_as_current_span(&quot;process&quot;) as span:\n        try:\n            f = fibonacci(n)\n            return f\n        except Exception as e:\n            logging.getLogger().exception(&quot;SeedNumber=%s&quot;,n)\n<span class=\"hljs-addition\">+           span.record_exception(e)</span>\n<span class=\"hljs-addition\">+           span.set_status(Status(StatusCode.ERROR))</span>\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: Do not copy the + character\n  </details></p>\n</blockquote>\n<p><br></p>\n<h4 id=\"verifyresults-1\">‚úÖ Verify Results</h4>\n<ol>\n<li>Open <code>Distributed trace</code> app</li>\n<li>Switch to <code>span</code> view and search for <code>process</code> spans</li>\n<li>You will notice that the span is now <strong><em>marked</em></strong> as failure and the corresponding metadata of the exceptions are also recorded for spans which have exceptions.</li>\n</ol>\n<p><details>\n<summary>üí° What are the considerations of logging the exception compared to inserting the exception message in the span itself?</summary>\n<p>- Having the exception messages recorded in spans provides a quick way to diagnose and troubleshoot an application.\n<p>- However, logging provides an easy way to also include other details/data that might not be suitable to input in the span events.\n<p>- OpenTelemetry provides the facilities to allow for either implementation and in fact, you can also implement both as well. However, there is always an element of cost and maintainability.\n<p>- Thus it is prudent to use the right method for the right objectives/purpose.\n</details></p>\n<p><br/></p>\n<h3 id=\"loggingbusinessdata\">Logging business data</h3>\n<ul>\n<li>When called, the python microserivce responses with a JSON payload, for example</li>\n</ul>\n<pre><code class=\"hljs bash language-bash\">curl http://localhost:8090/quote\n{amount: 14, currency: <span class=\"hljs-string\">&quot;USD&quot;</span>}\n</code></pre>\n<ul>\n<li>The payload is often used for business analytics or to understand the business impact of a failed service.</li>\n</ul>\n<h4 id=\"yourtask-2\">üìå Your Task</h4>\n<ul>\n<li>Think of a way to capture this information in Dynatrace.</li>\n<li><strong><em>hint</em></strong>: The python microservices is called using a Java <strong>http</strong> from <code>BackendServer.java</code></li>\n<li>As with every <strong>http</strong> calls, there is always a response header, response code and response body.</li>\n<li>Remember to rebuild the application after any modifications <code>docker compose up -d --build</code>.</li>\n</ul>\n<p><details>\n<summary><strong>Expand for solution</strong></summary>\n<p> You can choose to log the response in Java code, or log the output of the result in the Python code.\n<p> Here, we are showing an example of using Java to capture the information in Dynatrace.</p>\n<pre><code class=\"hljs diff language-diff\">    public static void notifyProcessingBackend(Product product) throws Exception {\n        GETRequest request = new GETRequest(&quot;http://order-quotes-&quot; + System.getenv(&quot;GITHUB_USER&quot;) + &quot;:&quot; + &quot;8090/quote&quot;);\n<span class=\"hljs-addition\">+        log.info(request.send());</span>\n    }\n</code></pre>\n<blockquote>\n  <p><strong>NOTE</strong>: Do not copy the + character</p>\n  <p>If you choose to log the data in the Python code, you will need to write more python code to configure the logging package for \"info\" logs. The default level is <code>WARNING</code>, which means that only events of this severity and higher will be tracked, unless the logging package is configured to do otherwise, reference: <a href=\"https://docs.python.org/3/howto/logging.html\">https://docs.python.org/3/howto/logging.html</a>.\n  </details></p>\n</blockquote>\n<p><br/></p>\n<h4 id=\"verifyresults-2\">‚úÖ Verify Results</h4>\n<ol>\n<li>Open <code>Logs</code> app</li>\n<li>Log entries should appear under the <code>service.name</code> of <code>order-backend-*</code></li>\n</ol>\n<p><details>\n<summary>üí° What benefits/disadvantages of logging on the Java side and Python side?</summary>\n<p> Java side: Only the caller would be interested in the responses, thus it is purdent to log at the caller side.\n<p> Python side: The Python service might not be only called by the Java application. If the python application developers need the context to diagnose, it is wise to log at the python side. \n</details></p>","activityList":[]}]}]